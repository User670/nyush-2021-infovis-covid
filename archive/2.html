<!DOCTYPE html>
<html>

<head>
    <title>New York COVID-19</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/d3-path.v2.min.js"></script>
    <script src="https://d3js.org/d3-shape.v2.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <script src="https://unpkg.com/react/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone/babel.js"></script>
    <style>
    .view-selector-selected{
        color: red
    }
    .view-selector-unselected{
        color: gray
    }
    </style>
</head>

<body>
    <p>
        <span id="radio1" class="view-selector-selected" onclick="switchToView1()"> View 1 </span>
        <span id="radio2" class="view-selector-unselected" onclick="switchToView2()"> View 2 </span>
    </p>
    <div id="root"></div>
    <script type="text/babel">
        const csvUrl = './data/data.csv';
        const mapUrl = "./data/Modified Zip Code Tabulation Areas (MODZCTA).geojson";
        function useData(csvPath) {
            const [dataAll, setData] = React.useState(null);
            React.useEffect(() => {
                d3.csv(csvPath).then(data => {
                    data.forEach(d => {
                        d.zipcode = +d.zipcode;
                        d.income = +d.income;
                        d.lat = +d.lat;
                        d.lon = +d.lon;
                        d.hosp_count = +d.hosp_count;
                        d.hosp_rate = parseFloat(d.hosp_rate);
                        d.death_count = parseFloat(d.death_count);
                        d.death_rate = parseFloat(d.death_rate);
                        //
                        d.pos_rate = +d.pos_rate;
                        d.tested = +d.tested;
                        d.pos = +d.pos;
                        d.test_rate = +d.test_rate;
                        d.treatment_ratio = d.hosp_count / d.pos; //derive a new attribute: popularity
                    });
                    setData(data);
                });
            }, []);
            return dataAll;
        }

        function useMap(jsonPath) {
            const [data, setData] = React.useState(null);
            React.useEffect(() => {
                d3.json(jsonPath).then(geoJsonData => {
                    setData(geoJsonData);
                })
            }, []);
            return data;
        }

        ///sharon
            function YAxes(props) {
                const {yScale,height,yText}=props;
                const ticks=yScale.ticks(9);
                return (
                    <g>
                        <line y2={height} stroke={`black`} />
                        {ticks.map(tickValue => {
                            return <g key={tickValue} transform={`translate(-10, ${yScale(tickValue)})`}>
                                <line x2={10} stroke={"black"} />
                                <text style={{textAnchor: 'end',fontSize: '10px'}}>
                                    {tickValue}
                                </text>
                            </g>
                        })}
                        <text style={{textAnchor: 'start',fontSize: '15px'}} transform={`translate(20, 110)rotate(-90)`}>
                            {yText||"COVID Death Rate"}
                        </text>
                    </g>)
            }

            function XAxes(props) {
                const {xScale,width,height}=props;
                console.log(xScale.ticks())
                const ticks=xScale.ticks();
                return (
                    <g>
                        <line x1={0} y1={height} x2={width} y2={height} stroke={`black`} />
                        {ticks.map(tickValue => {
                            return <g key={tickValue} transform={`translate(${xScale(tickValue)}, ${height})`}>
                                <line y2={5} stroke={"black"} />
                                <text style={{textAnchor: 'middle',fontSize: '10px'}} y={20}>
                                    {tickValue}
                                </text>
                            </g>
                        })}
                        <text style={{textAnchor: 'end',fontSize: '15px'}} transform={`translate(${width}, ${height-10})`}>
                            {"Median Incomes of All Household"}
                        </text>
                    </g>)
            }

            function Points(props) {
                const [selectedPoint,setSelectedPoint]=React.useState(null);
                const {data,xScale,yScale,width,height}=props;

                const mouseOver=d => {
                    setSelectedPoint(d.zipcode);
                };
                const mouseOut=() => {
                    setSelectedPoint(null);
                };
                const color=d => d.zipcode===selectedPoint? "red":"steelblue";
                const radius=d => d.zipcode===selectedPoint? 10:5;

                return (
                    <g>
                        {data.filter(d => d.zipcode!==selectedPoint).map(d => {
                            console.log(d.income,d.death_rate)
                            return <circle key={d.index} cx={xScale(d.income)}
                                cy={yScale(d.death_rate)} r={radius(d)} fill={color(d)} stroke={"black"}
                                onMouseOver={() => mouseOver(d)} onMouseOut={mouseOut}
                            />
                        })}

                        {selectedPoint&&<rect x="0" y="0" width={width} height={height/2} fill="#fce703" opacity="0.5" />}
                        {data.filter(d => d.zipcode===selectedPoint).map(d => {
                            //console.log(d.income,d.death_rate)
                            return <circle key={d.index} cx={xScale(d.income)}
                                cy={yScale(d.death_rate)} r={radius(d)} fill={color(d)} stroke={"black"}
                                onMouseOver={() => mouseOver(d)} onMouseOut={mouseOut}
                            />
                        })}
                    </g>)
            }


            function ScatterPlot(props) {
                const dataAll=useData(csvUrl);
                if(!dataAll) {
                    return <pre>Loading...</pre>;
                }
                const width=600;
                const height=800;
                const innerHeight=height-margin.top-margin.bottom;
                const innerWidth=width-margin.left-margin.right;

                const xScale=d3.scaleLinear()
                    .range([0,innerWidth])
                    .domain([0,d3.max(dataAll,d => d.income)]).nice();
                const yScale=d3.scaleLinear()
                    .range([innerHeight/2,0])
                    .domain([0,d3.max(dataAll,d => d.death_rate)]).nice();
                //const data = dataAll.filter(d => {
                //return d.month === "May";
                //})
                return <g transform={`translate(${margin.left}, ${margin.top})`}>
                    <Points data={dataAll} xScale={xScale} yScale={yScale} width={innerWidth} height={innerHeight} />
                    <YAxes yScale={yScale} height={innerHeight/2} />
                    <XAxes xScale={xScale} width={innerWidth} height={innerHeight/2} />
                </g>
            }

        ///sharon



        ///Map for view 1 (death_rate)
        function Map1(props) {
            const { x, y, map, data, height, width, selectedPlace, setSelectedPlace } = props;

            const projection = d3.geoMercator().fitSize([width, height], map);
            const path = d3.geoPath(projection);

            const deathRate = data.map(d => d.death_rate);
            const colorScale = d3.scaleQuantize()
                .range(["brown", "steelblue"])
                .domain([0,1]);

            const mouseOver = d => {
                setSelectedPlace(d.zipcode);
            };
            const mouseOut = () => {
                setSelectedPlace(null);
            };

            if (selectedPlace === null) {
                return <g transform={`translate(${x}, ${y})`}>
                    {map.features.map(feature => {
                        // feature.properties.modzcta can be 99999
                        // which is not present in data, causing `place` to be []
                        // when searching for it
                        const place = data.filter(d => d.zipcode == feature.properties.modzcta);
                        let drate=0
                        if(place.length>0){
                            drate=place[0].death_rate
                        }else{
                            drate=0
                        }
                        return <path key={feature.properties.modzcta + "boundary"} d={path(feature)}
                            style={{ fill: colorScale(drate)}} />
                    })}
                </g>
            } else {
                return <g transform={`translate(${x}, ${y})`}>
                    {map.features.map(feature => {
                        const place = data.filter(d => d.zipcode == feature.properties.modacta);
                        let drate=0
                        if(place.length>0) {
                            drate=place[0].death_rate
                        } else {
                            drate=0
                        }
                        return <path key={feature.properties.modzcta + "boundary"} d={path(feature)}
                            style={{ fill: colorScale(drate) }} />
                    })}
                </g>
            }
        }

        const COVID19 = () => {
            const [selectedPlace, setSelectedPlace] = React.useState(null);
            const data = useData(csvUrl);
            const map = useMap(mapUrl);
            if (!map || !data) {
                return <pre>Loading...</pre>;
            };
            const WIDTH = 1200;
            const HEIGHT = 800;
            const margin = { top: 20, right: 40, bottom: 160, left: 40, gap: 40 };
            const innerWidth = WIDTH - margin.left - margin.right - margin.gap;
            const innerHeight = HEIGHT - margin.top - margin.bottom - margin.gap;

            return <div>
                <svg width={WIDTH} height={HEIGHT}>
                    <Map1 x={margin.left} y={margin.top} height={innerHeight + margin.gap}
                        width={innerWidth / 2} data={data} map={map} selectedPlace={selectedPlace}
                        setSelectedPlace={setSelectedPlace} />
                </svg>
                <div style={{ position: "absolute", textAlign: "left", width: "240px", left: "40px", top: "40px" }}>
                    <h3>New York COVID-19</h3>
                    <p>A visualization of the death rate in New York</p>
                </div>

            </div>
        }
        ReactDOM.render(<COVID19 />, document.getElementById('root'));
    </script>

    <div id="view2" style="display:none" />
    <script type="text/babel">
        
        // top bar chart (hosp/100K)
        function BarChartHospitalizationRate(props){
            const {x, y, map, data, height, width, selectedPlace, setSelectedPlace} = props;
            let dataCopy=[]
            for(let i=0;i<data.length;i++){
                dataCopy.push(data[i])
            }
            dataCopy.sort( (a,b) => {
                return b.hosp_rate - a.hosp_rate;
            })
            for(let i=0; i<dataCopy.length; i++){
                dataCopy[i].rank=i
            }
            
            const xScale=d3.scaleLinear()
                .range([0, width])
                .domain([0, dataCopy.length])
            const yScale=d3.scaleLinear()
                .range([height,0])
                .domain([0, d3.max(dataCopy, (d)=>{return d.hosp_rate})])
                .nice()
            let rectElements=[]
            for(let i=0;i<dataCopy.length; i++){
                let d=dataCopy[i]
                rectElements.push(
                    <rect
                    x={xScale(i)} 
                    y={yScale(d.hosp_rate)} 
                    width={xScale(1)} 
                    height={height-yScale(d.hosp_rate)}
                    stroke={d.zipcode==selectedPlace? "black" : "#CCCCCC"}
                    fill={d.zipcode==selectedPlace? "red":"#EEEEEE"}
                    onMouseEnter={() => setSelectedPlace(d.zipcode)}
                    onMouseOut={() => setSelectedPlace(null)}
                    />
                )
            }

            return (
                <g transform={`translate(${x}, ${y})`}>
                    <line y2={height} stroke="black" />
                    {yScale.ticks(5).map(tickValue => {
                        return (
                            <g key={tickValue} transform={`translate(-10, ${yScale(tickValue)})`}>
                                <line x2={10} stroke="black" />
                                <text style={{textAnchor: 'end',fontSize: '10px'}}>{tickValue}</text>
                            </g>
                        )
                    })}
                    {rectElements}
                </g>
            )
        }

        // bottom bar chart (death/100K)
        // Unless necessary, copy from above
        function BarChartDeathRate(props) {
            const {x,y,map,data,height,width,selectedPlace,setSelectedPlace}=props;
            let dataCopy=[]
            for(let i=0;i<data.length;i++) {
                dataCopy.push(data[i])
            }
            dataCopy.sort((a,b) => {
                return b.death_rate-a.death_rate;
            })
            for(let i=0;i<dataCopy.length;i++) {
                dataCopy[i].rank=i
            }

            const xScale=d3.scaleLinear()
                .range([0,width])
                .domain([0,dataCopy.length])
            const yScale=d3.scaleLinear()
                .range([height,0])
                .domain([0,d3.max(dataCopy,(d) => {return d.death_rate})])
                .nice()
            let rectElements=[]
            for(let i=0;i<dataCopy.length;i++) {
                let d=dataCopy[i]
                rectElements.push(
                    <rect
                        x={xScale(i)}
                        y={yScale(d.death_rate)}
                        width={xScale(1)}
                        height={height-yScale(d.death_rate)}
                        stroke={d.zipcode==selectedPlace? "black":"#CCCCCC"}
                        fill={d.zipcode==selectedPlace? "red":"#EEEEEE"}
                        onMouseEnter={() => setSelectedPlace(d.zipcode)}
                        onMouseOut={() => setSelectedPlace(null)}
                    />
                )
            }

            return (
                <g transform={`translate(${x}, ${y})`}>
                    <line y2={height} stroke="black" />
                    {yScale.ticks(5).map(tickValue => {
                        return (
                            <g key={tickValue} transform={`translate(-10, ${yScale(tickValue)})`}>
                                <line x2={10} stroke="black" />
                                <text style={{textAnchor: 'end',fontSize: '10px'}}>{tickValue}</text>
                            </g>
                        )
                    })}
                    {rectElements}
                </g>
            )
        }


        //placeholder
        function Map2(props) {
            return <p />
            const {x,y,map,data,height,width,selectedPlace,setSelectedPlace}=props;

            const projection=d3.geoMercator().fitSize([width,height],map);
            const path=d3.geoPath(projection);

            const deathRate=data.map(d => d.death_rate);
            const colorScale=d3.scaleQuantize()
                .range(["brown","steelblue"])
                .domain([0,1]);

            const mouseOver=d => {
                setSelectedPlace(d.zipcode);
            };
            const mouseOut=() => {
                setSelectedPlace(null);
            };

            if(selectedPlace===null) {
                return <g transform={`translate(${x}, ${y})`}>
                    {map.features.map(feature => {
                        // feature.properties.modzcta can be 99999
                        // which is not present in data, causing `place` to be []
                        // when searching for it
                        const place=data.filter(d => d.zipcode==feature.properties.modzcta);
                        let drate=0
                        if(place.length>0) {
                            drate=place[0].death_rate
                        } else {
                            drate=0
                        }
                        return <path key={feature.properties.modzcta+"boundary"} d={path(feature)}
                            style={{fill: colorScale(drate)}} />
                    })}
                </g>
            } else {
                return <g transform={`translate(${x}, ${y})`}>
                    {map.features.map(feature => {
                        const place=data.filter(d => d.zipcode==feature.properties.modacta);
                        let drate=0
                        if(place.length>0) {
                            drate=place[0].death_rate
                        } else {
                            drate=0
                        }
                        return <path key={feature.properties.modzcta+"boundary"} d={path(feature)}
                            style={{fill: colorScale(drate)}} />
                    })}
                </g>
            }
        }

        const View2= () => {
            const [selectedPlace, setSelectedPlace] = React.useState(null);
            const data = useData(csvUrl);
            const map = useMap(mapUrl);
            if (!map || !data) {
                return <pre>Loading...</pre>;
            };
            const WIDTH = 1200;
            const HEIGHT = 800;
            const margin = { top: 20, right: 40, bottom: 160, left: 40, gap: 40 };
            const innerWidth = WIDTH - margin.left - margin.right - margin.gap;
            const innerHeight = HEIGHT - margin.top - margin.bottom - margin.gap;

            return <div>
                <svg width={WIDTH} height={HEIGHT}>
                    <Map2 x={margin.left} y={margin.top} height={innerHeight + margin.gap}
                        width={innerWidth / 2} data={data} map={map} selectedPlace={selectedPlace}
                        setSelectedPlace={setSelectedPlace} />
                    <BarChartHospitalizationRate x={margin.left} y={margin.top} height={innerHeight*0.45+margin.gap}
                        width={innerWidth*0.6} data={data} map={map} selectedPlace={selectedPlace}
                        setSelectedPlace={setSelectedPlace} />
                    <BarChartDeathRate x={margin.left} y={margin.top+innerHeight*0.55} height={innerHeight*0.45+margin.gap}
                        width={innerWidth*0.6} data={data} map={map} selectedPlace={selectedPlace}
                        setSelectedPlace={setSelectedPlace} />
                </svg>
                <div style={{ position: "absolute", textAlign: "left", width: "240px", left: "40px", top: "40px" }}>
                    <h3>New York COVID-19</h3>
                    <p>A visualization of the death rate in New York</p>
                </div>

            </div>
        }
        
        ReactDOM.render(<View2 />, document.getElementById("view2"));
    </script>

    <script>
        function switchToView1(){
            document.getElementById("root").style.display=""
            document.getElementById("view2").style.display="none"
            document.getElementById("radio1").className="view-selector-selected"
            document.getElementById("radio2").className="view-selector-unselected"
        }
        function switchToView2() {
            document.getElementById("root").style.display="none"
            document.getElementById("view2").style.display=""
            document.getElementById("radio1").className="view-selector-unselected"
            document.getElementById("radio2").className="view-selector-selected"
        }
        
        let urlParameters=new URLSearchParams(window.location.search);
        if (urlParameters.has("view2")){
            switchToView2()
        }

    </script>
</body>

</html>